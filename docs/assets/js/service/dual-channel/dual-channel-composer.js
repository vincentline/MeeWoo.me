!function(a){"use strict";window.MeeWoo=window.MeeWoo||{},window.MeeWoo.Services=window.MeeWoo.Services||{};var e={defaults:{mode:"color-left-alpha-right",jpegQuality:.6,format:"jpeg",workerPath:"assets/js/service/dual-channel/dual-channel-worker.js"},_worker:null,_taskId:0,_initWorker:function(){if(!this._worker)try{console.log("开始初始化Web Worker");const a=new Blob(["\n// 分块大小配置\nconst BLOCK_SIZE = 128;\n\n// 检测SIMD支持\nconst hasSIMD = false;\n\n// 处理消息\nself.onmessage = function(e) {\n  var task = e.data;\n  console.log('Worker received task:', task.type, 'Task ID:', task.id);\n  \n  try {\n    switch(task.type) {\n      case 'composeFrame':\n        console.log('Processing composeFrame task');\n        handleComposeFrame(task).catch(function(error) {\n          console.error('Error in handleComposeFrame:', error);\n          self.postMessage({ id: task.id, type: 'error', error: error.message });\n        });\n        break;\n      case 'composeFrames':\n        console.log('Processing composeFrames task, frame count:', task.data.frames.length);\n        handleComposeFrames(task).catch(function(error) {\n          console.error('Error in handleComposeFrames:', error);\n          self.postMessage({ id: task.id, type: 'error', error: error.message });\n        });\n        break;\n      default:\n        throw new Error('Unknown task type: ' + task.type);\n    }\n  } catch(error) {\n    console.error('Error in message handler:', error);\n    self.postMessage({ id: task.id, type: 'error', error: error.message });\n  }\n};\n\nasync function handleComposeFrame(task) {\n  console.log('Starting handleComposeFrame, frame data length:', task.frame.data.length, 'width:', task.width, 'height:', task.height);\n  \n  var frameData = task.frame.data;\n  var width = task.width;\n  var height = task.height;\n  var mode = task.mode;\n  var isColorLeftAlphaRight = mode === 'color-left-alpha-right';\n  \n  var dualWidth = width * 2;\n  var dualHeight = height;\n  var dualDataSize = dualWidth * dualHeight * 4;\n  \n  console.log('Dual channel image size:', dualWidth, 'x', dualHeight, 'data size:', dualDataSize);\n  \n  var dualData = new Uint8ClampedArray(dualDataSize);\n  var blackBgData = new Uint8ClampedArray(dualDataSize);\n  \n  console.log('Memory allocated successfully');\n  \n  var blocks = [];\n  console.log('Generating blocks...');\n  for (var y = 0; y < height; y += BLOCK_SIZE) {\n    for (var x = 0; x < width; x += BLOCK_SIZE) {\n      blocks.push({ x: x, y: y, width: Math.min(BLOCK_SIZE, width - x), height: Math.min(BLOCK_SIZE, height - y) });\n    }\n  }\n  \n  console.log('Generated', blocks.length, 'blocks');\n  \n  console.log('Starting parallel processing of blocks...');\n  try {\n    var processedBlocks = 0;\n    var totalBlocks = blocks.length;\n    \n    await Promise.all(blocks.map(async block => {\n      await processBlock(block, frameData, width, height, dualWidth, dualData, blackBgData, isColorLeftAlphaRight);\n      \n      processedBlocks++;\n      var progress = Math.round((processedBlocks / totalBlocks) * 100);\n      \n      if (progress % 5 === 0) {\n        self.postMessage({ id: task.id, type: 'progress', progress: progress });\n      }\n    }));\n    console.log('Block processing completed');\n  } catch (error) {\n    console.error('Error during block processing:', error);\n    throw error;\n  }\n  \n  console.log('Posting result back to main thread');\n  self.postMessage({ id: task.id, type: 'result', result: { blackBgData: blackBgData, dualData: dualData, width: dualWidth, height: dualHeight } }, [blackBgData.buffer, dualData.buffer]);\n  console.log('Result posted successfully');\n}\n\nasync function handleComposeFrames(task) {\n  console.log('Starting handleComposeFrames, frame count:', task.data.frames.length);\n  \n  var data = task.data;\n  var frames = data.frames;\n  var mode = data.mode;\n  var frameCount = frames.length;\n  \n  if (frameCount === 0) {\n    throw new Error('帧数组不能为空');\n  }\n  \n  console.log('First frame size:', frames[0].width, 'x', frames[0].height);\n  \n  var results = [];\n  var width = frames[0].width;\n  var height = frames[0].height;\n  var isColorLeftAlphaRight = mode === 'color-left-alpha-right';\n  var dualWidth = width * 2;\n  var dualDataSize = dualWidth * height * 4;\n  \n  console.log('Dual channel image size per frame:', dualWidth, 'x', height, 'data size:', dualDataSize);\n  \n  const BATCH_SIZE = 20;\n  console.log('Worker使用分批处理，每批', BATCH_SIZE, '帧');\n  \n  for (let batchStart = 0; batchStart < frameCount; batchStart += BATCH_SIZE) {\n    const batchEnd = Math.min(batchStart + BATCH_SIZE, frameCount);\n    const batchFrames = frames.slice(batchStart, batchEnd);\n    const batchSize = batchFrames.length;\n    console.log('Worker处理批次:', batchStart, '-', batchEnd, '共', batchSize, '帧');\n    \n    var framePromises = batchFrames.map(async function(frameData, index) {\n      const frameIndex = batchStart + index;\n      console.log('Processing frame', frameIndex + 1, 'of', frameCount);\n      \n      var dualData = new Uint8ClampedArray(dualDataSize);\n      var blackBgData = new Uint8ClampedArray(dualDataSize);\n      \n      console.log('Memory allocated for frame', frameIndex);\n      \n      var blocks = [];\n      for (var y = 0; y < height; y += BLOCK_SIZE) {\n        for (var x = 0; x < width; x += BLOCK_SIZE) {\n          blocks.push({ x: x, y: y, width: Math.min(BLOCK_SIZE, width - x), height: Math.min(BLOCK_SIZE, height - y) });\n        }\n      }\n      \n      console.log('Generated', blocks.length, 'blocks for frame', frameIndex);\n      \n      try {\n        await Promise.all(blocks.map(block => processBlock(block, frameData.data, width, height, dualWidth, dualData, blackBgData, isColorLeftAlphaRight)));\n        console.log('Frame', frameIndex, 'processing completed');\n      } catch (error) {\n        console.error('Error processing frame', frameIndex, ':', error);\n        return null;\n      }\n      \n      return { blackBgData: blackBgData, width: dualWidth, height: height };\n    });\n    \n    console.log('Waiting for batch frames to complete...');\n    try {\n      const batchResults = await Promise.all(framePromises);\n      \n      const validResults = batchResults.filter(result => result !== null);\n      results.push(...validResults);\n      \n      console.log('Batch processed successfully, valid results:', validResults.length);\n      \n      const processedFrames = Math.min(batchEnd, frameCount);\n      var progress = Math.round((processedFrames / frameCount) * 100);\n      \n      if (progress % 5 === 0) {\n        self.postMessage({ id: task.id, type: 'progress', progress: progress });\n      }\n      \n      console.log('Batch completed, total results so far:', results.length);\n    } catch (error) {\n      console.error('Error in batch processing:', error);\n      continue;\n    }\n  }\n  \n  var transferables = [];\n  results.forEach(result => {\n    transferables.push(result.blackBgData.buffer);\n  });\n  \n  console.log('Extracted transferable objects, count:', transferables.length);\n  \n  console.log('Posting results back to main thread');\n  self.postMessage({ id: task.id, type: 'result', result: results }, transferables);\n  \n  console.log('Results posted successfully, total frames processed:', results.length);\n}\n\nfunction processBlock(block, frameData, width, height, dualWidth, dualData, blackBgData, isColorLeftAlphaRight) {\n  return new Promise(function(resolve) {\n    var startX = block.x;\n    var startY = block.y;\n    var blockWidth = block.width;\n    var blockHeight = block.height;\n    \n    console.log('Processing block:', startX, ',', startY, 'size:', blockWidth, 'x', blockHeight);\n    \n    var inv255 = 1 / 255;\n    \n    try {\n      processBlockWithoutSIMD(block, frameData, width, height, dualWidth, dualData, blackBgData, isColorLeftAlphaRight, inv255);\n      \n      console.log('Block processing completed:', startX, ',', startY);\n      resolve();\n    } catch (error) {\n      console.error('Error processing block:', error, 'at position:', startX, ',', startY);\n      resolve();\n    }\n  });\n}\n\nfunction processBlockWithoutSIMD(block, frameData, width, height, dualWidth, dualData, blackBgData, isColorLeftAlphaRight, inv255) {\n  var startX = block.x;\n  var startY = block.y;\n  var blockWidth = block.width;\n  var blockHeight = block.height;\n  \n  console.log('Processing block without SIMD:', startX, ',', startY, 'size:', blockWidth, 'x', blockHeight);\n  \n  var pixelCount = 0;\n  for (var y = startY; y < startY + blockHeight; y++) {\n    for (var x = startX; x < startX + blockWidth; x++) {\n      try {\n        processSinglePixel(x, y, frameData, width, dualWidth, dualData, blackBgData, isColorLeftAlphaRight, inv255);\n        pixelCount++;\n      } catch (error) {\n        console.error('Error processing pixel at', x, ',', y, ':', error);\n      }\n    }\n  }\n  \n  console.log('Block processing completed, total pixels:', pixelCount);\n}\n\nfunction processSinglePixel(x, y, frameData, width, dualWidth, dualData, blackBgData, isColorLeftAlphaRight, inv255) {\n  var pixelIndex = y * width + x;\n  var frameIdx = pixelIndex * 4;\n  \n  if (frameIdx + 3 >= frameData.length) {\n    console.error('Invalid frame index:', frameIdx, 'for frame data length:', frameData.length);\n    return;\n  }\n  \n  var r = frameData[frameIdx + 0];\n  var g = frameData[frameIdx + 1];\n  var b = frameData[frameIdx + 2];\n  var a = frameData[frameIdx + 3];\n\n  var finalR = r, finalG = g, finalB = b;\n  if (a > 0) {\n    if (a < 255) {\n      var alphaFactor = 255 * inv255;\n      finalR = Math.min(255, Math.round(r * alphaFactor));\n      finalG = Math.min(255, Math.round(g * alphaFactor));\n      finalB = Math.min(255, Math.round(b * alphaFactor));\n    }\n  } else {\n    finalR = 0; finalG = 0; finalB = 0;\n  }\n\n  var leftIdx = (y * dualWidth + x) * 4;\n  var rightIdx = (y * dualWidth + x + width) * 4;\n\n  if (leftIdx + 3 >= dualData.length || rightIdx + 3 >= dualData.length) {\n    console.error('Invalid dual data index:', leftIdx, 'or', rightIdx, 'for dual data length:', dualData.length);\n    return;\n  }\n\n  if (isColorLeftAlphaRight) {\n    dualData[leftIdx + 0] = finalR;\n    dualData[leftIdx + 1] = finalG;\n    dualData[leftIdx + 2] = finalB;\n    dualData[leftIdx + 3] = a;\n    dualData[rightIdx + 0] = a;\n    dualData[rightIdx + 1] = a;\n    dualData[rightIdx + 2] = a;\n    dualData[rightIdx + 3] = 255;\n  } else {\n    dualData[leftIdx + 0] = a;\n    dualData[leftIdx + 1] = a;\n    dualData[leftIdx + 2] = a;\n    dualData[leftIdx + 3] = 255;\n    dualData[rightIdx + 0] = finalR;\n    dualData[rightIdx + 1] = finalG;\n    dualData[rightIdx + 2] = finalB;\n    dualData[rightIdx + 3] = a;\n  }\n\n  var pixelAlphaLeft = dualData[leftIdx + 3];\n  if (pixelAlphaLeft === 255) {\n    blackBgData[leftIdx + 0] = dualData[leftIdx + 0];\n    blackBgData[leftIdx + 1] = dualData[leftIdx + 1];\n    blackBgData[leftIdx + 2] = dualData[leftIdx + 2];\n  } else if (pixelAlphaLeft === 0) {\n    blackBgData[leftIdx + 0] = 0;\n    blackBgData[leftIdx + 1] = 0;\n    blackBgData[leftIdx + 2] = 0;\n  } else {\n    var alphaFactorLeft = pixelAlphaLeft * inv255;\n    blackBgData[leftIdx + 0] = Math.round(dualData[leftIdx + 0] * alphaFactorLeft);\n    blackBgData[leftIdx + 1] = Math.round(dualData[leftIdx + 1] * alphaFactorLeft);\n    blackBgData[leftIdx + 2] = Math.round(dualData[leftIdx + 2] * alphaFactorLeft);\n  }\n  blackBgData[leftIdx + 3] = 255;\n\n  var pixelAlphaRight = dualData[rightIdx + 3];\n  if (pixelAlphaRight === 255) {\n    blackBgData[rightIdx + 0] = dualData[rightIdx + 0];\n    blackBgData[rightIdx + 1] = dualData[rightIdx + 1];\n    blackBgData[rightIdx + 2] = dualData[rightIdx + 2];\n  } else if (pixelAlphaRight === 0) {\n    blackBgData[rightIdx + 0] = 0;\n    blackBgData[rightIdx + 1] = 0;\n    blackBgData[rightIdx + 2] = 0;\n  } else {\n    var alphaFactorRight = pixelAlphaRight * inv255;\n    blackBgData[rightIdx + 0] = Math.round(dualData[rightIdx + 0] * alphaFactorRight);\n    blackBgData[rightIdx + 1] = Math.round(dualData[rightIdx + 1] * alphaFactorRight);\n    blackBgData[rightIdx + 2] = Math.round(dualData[rightIdx + 2] * alphaFactorRight);\n  }\n  blackBgData[rightIdx + 3] = 255;\n}\n                "],{type:"application/javascript"}),e=URL.createObjectURL(a);console.log("创建Worker Blob URL成功:",e),this._worker=new Worker(e),console.log("Web Worker 内联代码加载成功")}catch(a){throw console.error("Worker内联代码加载失败:",a),new Error("无法加载Web Worker: "+a.message)}},_sendTask:function(a,e,t){const n=(t=t||{}).onProgress||function(){};return new Promise((t,r)=>{try{this._initWorker();const o=++this._taskId,l={id:o,type:a,data:e},s=a=>{a.data.id===o&&("progress"===a.data.type?n(a.data.progress/100):(this._worker.removeEventListener("message",s),this._worker.removeEventListener("error",i),"error"===a.data.type?(console.error("Worker任务错误:",a.data.error),r(new Error(a.data.error))):t(a.data.result)))},i=a=>{console.error("Web Worker错误:",a),this._worker.removeEventListener("message",s),this._worker.removeEventListener("error",i),this._worker=null,r(new Error("Web Worker执行错误: "+(a.message||"未知错误")))};this._worker.addEventListener("error",i),this._worker.addEventListener("message",s),console.log("发送任务到Worker，类型:",a,"任务ID:",o),this._worker.postMessage(l)}catch(a){console.error("发送任务失败:",a),r(new Error("发送任务到Worker失败: "+a.message))}})},composeSingleFrame:async function(a,e){const t=(e=e||{}).mode||this.defaults.mode,n=e.format||this.defaults.format,r=e.quality,o=e.onProgress||function(){};if(!a||!a.data)throw new Error("无效的ImageData对象");const l=a.width,s=a.height;let i=r;if(void 0===i&&"jpeg"===n){const a=2*l*s;i=a<5e5?.7:a>2e6?.5:.6}const c=await this._sendTask("composeFrame",{frame:a,mode:t,width:l,height:s},{onProgress:o}),d=document.createElement("canvas");d.width=2*l,d.height=s;const h=d.getContext("2d",{alpha:!0,willReadFrequently:!0}),g=h.createImageData(2*l,s);g.data.set(c.dualData),h.putImageData(g,0,0);const f=document.createElement("canvas");f.width=2*l,f.height=s;const u=f.getContext("2d"),m=u.createImageData(2*l,s);m.data.set(c.blackBgData),u.putImageData(m,0,0);const p=await new Promise(function(a){"png"===n?f.toBlob(a,"image/png"):f.toBlob(a,"image/jpeg",i)}),k=await p.arrayBuffer();return d.width=0,d.height=0,f.width=0,f.height=0,new Uint8Array(k)},composeToJPEG:async function(a,e){return this.composeFrames(a,e)},composeFrames:async function(a,e){const t=(e=e||{}).mode||this.defaults.mode,n=e.format||this.defaults.format,r=e.quality,o=e.onProgress||function(){},l=e.onCancel||function(){return!1},s=a.length;if(console.log("开始批量合成双通道图像，帧数:",s,"格式:",n,"模式:",t),0===s)throw new Error("帧数组不能为空");const i=[],c=a[0].width,d=a[0].height;console.log("图像尺寸:",c,"x",d,"双通道尺寸:",2*c,"x",d);let h=r;if(void 0===h&&"jpeg"===n){const a=2*c*d;h=a<5e5?.7:a>2e6?.5:.6,console.log("自适应JPEG质量:",h)}console.log("使用分批处理，每批",50,"帧");for(let e=0;e<s;e+=50){if(l())throw new Error("用户取消");const r=Math.min(e+50,s),g=a.slice(e,r),f=g.length;console.log("处理批次:",e,"-",r,"共",f,"帧"),console.log("开始使用Web Worker处理批次");const u=await this._sendTask("composeFrames",{frames:g,mode:t,width:c,height:d,frameCount:f},{onProgress:function(a){o((e+a*f)/s)}});console.log("Web Worker批次处理完成，返回结果数:",u.length);for(let a=0;a<f;a++){if(l())throw new Error("用户取消");try{const t=document.createElement("canvas");t.width=2*c,t.height=d;const r=t.getContext("2d"),l=r.createImageData(2*c,d);l.data.set(u[a].blackBgData),r.putImageData(l,0,0);const g=await new Promise(function(a){"png"===n?t.toBlob(a,"image/png"):t.toBlob(a,"image/jpeg",h)}),f=await g.arrayBuffer();i.push(new Uint8Array(f)),t.width=0,t.height=0;const m=e+a;o((m+1)/s),(m+1)%10==0&&await new Promise(function(a){setTimeout(a,0)})}catch(t){console.error("处理帧",e+a,"时出错:",t);continue}}"function"==typeof gc&&gc(),console.log("批次处理完成，已处理总帧数:",i.length)}return console.log("批量合成双通道图像完成，生成帧数:",i.length),i},setConfig:function(a){Object.assign(this.defaults,a)},getConfig:function(){return{...this.defaults}},destroy:function(){this._worker&&(this._worker.terminate(),this._worker=null)}};"undefined"!=typeof module&&module.exports?module.exports=e:a.MeeWoo.Services.DualChannelComposer=e}("undefined"!=typeof window?window:this);