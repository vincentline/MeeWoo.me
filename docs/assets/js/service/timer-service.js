!function(t){"use strict";function e(){this.timers=new Map,this.timerCounter=0,this.debugMode=!1}t.MeeWoo=t.MeeWoo||{},t.MeeWoo.Service=t.MeeWoo.Service||{},e.prototype._generateId=function(){return this.timerCounter++,"timer_"+Date.now()+"_"+this.timerCounter},e.prototype._log=function(t,...e){this.debugMode&&console.log("[TimerService] "+t,...e)},e.prototype._error=function(t,e){console.error("[TimerService] "+t,e||"")},e.prototype.createDelay=function(t,e,r){if("function"!=typeof t)return this._error("createDelay: callback 必须是函数"),null;if("number"!=typeof e||e<0)return this._error("createDelay: delay 必须是非负数"),null;const n=this._generateId(),i=Date.now(),o=setTimeout(()=>{try{t()}catch(t){this._error("延迟执行回调出错 ("+n+")",t)}finally{this.timers.delete(n),this._log("延迟定时器完成:",n)}},e),s={id:n,type:"delay",callback:t,delay:e,groupId:r||null,nativeId:o,startTime:i,status:"pending"};return this.timers.set(n,s),this._log("创建延迟定时器:",n,"延迟:",e+"ms","分组:",r||"无"),n},e.prototype.createInterval=function(t,e,r,n){if("function"!=typeof t)return this._error("createInterval: callback 必须是函数"),null;if("number"!=typeof e||e<=0)return this._error("createInterval: interval 必须是正数"),null;const i=this._generateId(),o=Date.now();let s=0;const l=()=>{s++;try{t()}catch(t){this._error("周期执行回调出错 ("+i+", 第"+s+"次)",t)}},a=setInterval(l,e),c={id:i,type:"interval",callback:t,interval:e,groupId:r||null,nativeId:a,startTime:o,executionCount:s,status:"running",immediate:n||!1};return this.timers.set(i,c),this._log("创建周期定时器:",i,"间隔:",e+"ms","分组:",r||"无"),n&&l(),i},e.prototype.cancel=function(t){if(!this.timers.has(t))return this._log("取消失败：定时器不存在",t),!1;const e=this.timers.get(t);try{return"delay"===e.type?clearTimeout(e.nativeId):"interval"===e.type&&clearInterval(e.nativeId),this.timers.delete(t),e.status="cancelled",this._log("取消定时器:",t,"类型:",e.type,"分组:",e.groupId),!0}catch(e){return this._error("取消定时器失败 ("+t+")",e),!1}},e.prototype.cancelByGroup=function(t){if(!t)return this._error("cancelByGroup: groupId 不能为空"),0;let e=0;const r=[];return this.timers.forEach((e,n)=>{e.groupId===t&&r.push(n)}),r.forEach(t=>{this.cancel(t)&&e++}),this._log("按分组取消定时器:",t,"取消数量:",e),e},e.prototype.cancelAll=function(){let t=0;return Array.from(this.timers.keys()).forEach(e=>{this.cancel(e)&&t++}),this._log("取消所有定时器，总数量:",t),t},e.prototype.getInfo=function(t){if(!this.timers.has(t))return null;const e=this.timers.get(t);return{id:e.id,type:e.type,groupId:e.groupId,status:e.status,startTime:e.startTime,delay:e.delay,interval:e.interval,executionCount:e.executionCount}},e.prototype.getCountByGroup=function(t){if(!t)return 0;let e=0;return this.timers.forEach(r=>{r.groupId===t&&e++}),e},e.prototype.getStats=function(){const t={total:this.timers.size,byType:{delay:0,interval:0},byStatus:{pending:0,running:0,completed:0,cancelled:0},byGroup:{}};return this.timers.forEach(e=>{void 0!==t.byType[e.type]&&t.byType[e.type]++,void 0!==t.byStatus[e.status]&&t.byStatus[e.status]++;const r=e.groupId||"(未分组)";t.byGroup[r]||(t.byGroup[r]=0),t.byGroup[r]++}),t},e.prototype.createPoll=function(t,e,r,n,i){if("function"!=typeof t)return this._error("createPoll: conditionFn 必须是函数"),null;if("function"!=typeof e)return this._error("createPoll: callback 必须是函数"),null;if("number"!=typeof r||r<=0)return this._error("createPoll: interval 必须是正数"),null;const o=this._generateId(),s=Date.now();let l=0;const a=()=>{l++;try{if(t())return this._log("轮询条件满足，停止 ("+o+", 次数:"+l+")"),void this.cancel(o);e(l),n>0&&Date.now()-s>=n&&(this._log("轮询超时，停止 ("+o+", 次数:"+l+")"),this.cancel(o))}catch(t){this._error("轮询执行出错 ("+o+")",t),this.cancel(o)}},c=setInterval(a,r),u={id:o,type:"poll",callback:e,conditionFn:t,interval:r,timeout:n||0,groupId:i||null,nativeId:c,startTime:s,pollCount:0,status:"running"};return this.timers.set(o,u),this._log("创建轮询定时器:",o,"间隔:",r+"ms","超时:",n+"ms"),a(),o},e.prototype.createRetry=function(t,e,r,n){if("function"!=typeof t)return this._error("createRetry: taskFn 必须是函数"),null;if("number"!=typeof e||e<=0)return this._error("createRetry: maxRetries 必须是正数"),null;if("number"!=typeof r||r<0)return this._error("createRetry: retryDelay 必须是非负数"),null;const i=this._generateId();let o=0,s=!1;const l=()=>{if(!s){o++,this._log("重试任务执行 ("+i+", 第"+o+"次尝试)");try{const a=t();a&&"function"==typeof a.then?a.then(()=>{s=!0,this.cancel(i),this._log("重试任务成功 ("+i+")")}).catch(t=>{this._error("重试任务失败 ("+i+")",t),o<e?this.createDelay(l,r,n):(s=!0,this.cancel(i),this._log("重试任务达到最大次数，放弃 ("+i+")"))}):(s=!0,this.cancel(i),this._log("重试任务成功 ("+i+")"))}catch(t){this._error("重试任务异常 ("+i+")",t),o<e?this.createDelay(l,r,n):(s=!0,this.cancel(i),this._log("重试任务达到最大次数，放弃 ("+i+")"))}}},a={id:i,type:"retry",taskFn:t,maxRetries:e,retryDelay:r,groupId:n||null,nativeId:null,startTime:Date.now(),attemptCount:0,status:"running"};return this.timers.set(i,a),this._log("创建重试定时器:",i,"最大重试:",e,"延迟:",r+"ms"),l(),i},t.MeeWoo.Service.TimerService=new e,t.MeeWoo.Service.TimerServiceConstructor=e}(window);